▼フロント
npx openapi-typescript-codegen --input openapi.yaml --output src/api

▼バックエンド
※Java 8以上が必要
npx @openapitools/openapi-generator-cli generate \
  -i openapi.yaml \
  -g nodejs-express-server \
  -o backend

▼ドキュメント
openapi-generator-cli generate -i openapi.yaml -g html2 -o ./docs

▼ローカルサーバ起動
npm start


テストファイルの置き方について
各コンポーネントやモジュールの隣にテストファイルを配置する「Colocation」を採用で問題ないと思います。

以下は例ですが、↓のような置き方になると思います。
src/
├── components/
│   ├── atoms/
│   │   ├── Button/
│   │   │   ├── Button.tsx
│   │   │   ├── Button.test.tsx （Buttonコンポーネントの単体テスト）
│   │   │   └── Button.module.css
│   │   └── TextArea/
│   │       ├── TextArea.tsx
│   │       └── TextArea.test.tsx
│   │       └── TextArea.module.css
│   ├── molecules/
│   │   ├── Search/
│   │   │   ├── Search.tsx
│   │   │   └── Search.test.tsx （Searchコンポーネントの単体テスト)
│   │   └── User/
│   │       ├── User.tsx
│   │       └── User.test.tsx
～～～～～～～～～
├── utils/
│   ├── validators.ts
│   ├── validators.test.ts （ユーティリティ関数の単体テスト）
└── App.tsx

https://www.makotot.dev/posts/colocation-translation-ja
新しい人（もしくは半年後の自分自身）がコードを読むとき、 すぐにそのモジュールがテストされていることを見て取れて、そのモジュールの理解の助けとしてテストのファイルを利用できます。変更があれば、その変更に関連するテストの更新（追加 / 削除 / 修正）のリマインドとなります。
React Testing Libraryの作者の引用になりますが、テストコードからモジュール理解の助けになる。モジュール変更時にテストコード変更のりマインドになるなどがあると思います。
ここだけだと、srcと並列ディレクトリにtestコード作るのも変わらないのでは？と思ったのですが、個人的に以下の点でAtomic Designとの相性の良さを加味してColocation採用した方が良いと感じました。
・階層的なテストの明確化
　→　atomsなら完全に独立した単体テスト。moleculesならAtoms間の連携を含む単体・結合テストといったようにどの階層で、どのような粒度のテストを書くべきかが直感的に分かりやすくなると思います。
・関心の分離の視覚化
　→　例えば、Buttonという機能の関心事に関わる全てのファイル（コード、スタイル、テスト）が物理的にまとまっているため、Buttonの責任範囲が明確になります。
　　　他のコンポーネントのファイルが混ざらないため、関心の分離がファイルシステム上でも視覚的に実現されると考えてます。

テスト方法について
単体テストでやること
・各API呼び出しテスト＆APIレスポンスの型安全確認
　→　ここは推奨されているMSWというツールを使ってみようと思います。jest.mockも試してみて、使用感などお伝えします。

・UIデザインテスト
　→　画面単位でモック通りにデザインが実装されているか、ボタン等の部品が動くかを画面上で確認する。
　　　状態の変更によってUIが正しく更新されるか。

・Atoms,Molecules,utils,stateのソースコードテスト（Moleculesは結合ともグレーな部分ではありますが、デザインテストにかかるのでここでやりたい）
　→　ツールはJest + React Testing Libraryを想定。mochaなどテストコードが書けるツールはありそうだが、情報量も多くやりたいテストができそうなので。
　観点としては以下を想定
　・コンポーネントのレンダリング
　　コンポーネントがエラーなく正常にレンダリングされるか。
　　Propsに応じて表示内容が正しく変化するか。
　　条件付きレンダリングが正しく機能するか（例: isLoadingでローディング表示、データがある時にデータ表示）。
　・イベントハンドリング:
　　クリック、フォーム入力などのイベントが正しく発火し、対応する関数が呼び出されるか。
　　イベントハンドラに渡される引数が正しいか。
　・状態管理 (useState, useReducerなど):
　　コンポーネント内部の状態が正しく更新されるか。
　　状態の変更によってUIが正しく更新されるか。
　・カスタムフック (Custom Hooks):
　　カスタムフックが期待通りの値を返すか。
　　副作用（API呼び出しなど）が正しく処理されるか。
　・関数やロジック:
　　コンポーネント内部で使用されるユーティリティ関数や計算ロジックが正しい結果を返すか。
　　エッジケース（空のデータ、不正な入力など）が正しく処理されるか。

結合テストでやること
・機能一覧をもとに、各機能が画面上で動作するか確認する。（異常系含む）
・features,pagesのソースコードテスト
コンポーネント間の連携: 親子コンポーネント間のPropsの伝播、イベントの処理、Context APIやReduxなどの状態管理によるデータの流れが正しいか。
モジュール間の連携: UIコンポーネントと、APIクライアント、ユーティリティ関数、カスタムフックなどのロジック層が正しく連携するか。
外部システムとの統合: 模擬的に（モックして）APIサーバーや外部サービスとの通信を行い、データの取得・送信・エラーハンドリングがUIに正しく反映されるか。
ユーザーフローの一部: 特定の画面内で、ユーザーが複数の操作を行ったときに、一連のインタラクションが期待通りに機能するか。
ルーティング: 特定のURLへのアクセスやリンククリックで、正しいページがレンダリングされるか。

コンポーネント間の連携:
親コンポーネントから子コンポーネントへのPropsの伝播が正しく行われているか。
子コンポーネントからのイベントが親コンポーネントで正しく処理され、状態が更新されるか。
Context APIやReduxなどの状態管理ライブラリを使用している場合、状態が正しく共有・更新され、それに応じてUIが変化するか。
外部サービスとの連携:
API呼び出しが正しく行われ、取得したデータがUIに反映されるか。
エラーハンドリング（ネットワークエラー、APIからのエラーレスポンスなど）が正しく機能するか。
ローディング状態、データなしの状態などが正しく表示されるか。
ルーティング:
リンククリックやURL直打ちで、正しいページがレンダリングされるか。
URLパラメータが正しく処理され、それに応じたデータが表示されるか。
フォームのインタラクション:
複数の入力フィールドを持つフォームが、入力値の検証、送信、エラー表示などを含めて正しく動作するか。
フォームの送信後に、期待されるアクション（API呼び出し、ページ遷移など）が行われるか。
ユーザーフロー:
特定のユーザーシナリオ（例: ログイン→商品検索→カート追加→購入完了）が、一連の操作を通じて正しく完了するか。
各ステップで期待されるUIの変更やデータの更新が行われるか。
Atomic Designにおける結合テストの視点
Organisms:
MoleculesとAtomsが組み合わさってできた複雑なUIブロック（ヘッダー、フッター、商品一覧、フォームなど）が、それぞれの内部で連携して正しく動作することを確認します。
特に、Organisms内の状態管理や、Molecules/Atomsからのイベントを受けての振る舞いを確認します。
Templates:
Organismsが配置されたページ構造が、期待通りにレンダリングされることを確認します。
